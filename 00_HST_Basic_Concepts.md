# 00_HST_Basic_Concepts — Holographic Sphere Topology 基本概念

[Holographic Sphere Topology (HST)](https://www.tanaakk.com/2026/02/26/tech/) の基本概念を整理する。臓器メタファーと境界面（ホログラフィー）の定義により、システム開発を **Object と Morphism の数学的問題** に置き換える。

**参照**: [Holographic Sphere Topology – TANAAKK](https://www.tanaakk.com/2026/02/26/tech/)

---

## 1. 臓器メタファー：フロントエンドとバックエンドの分離

### 1.1 肝臓＝データベースの原則

| 臓器 | システム対応 | 役割 |
|------|-------------|------|
| **肝臓** | データベース（バックエンド） | 代謝・貯蔵。生データを直接受け取らない |
| **口・胃・腸** | フロントエンド・API 層 | 入力を咀嚼・消化し、**処理可能な形式**に変換してからバックエンドへ引き渡す |

**原則**: 肝臓に直接食べ物を接触させる人はいない。口や胃などのフロントエンドで処理した後、**簡単に処理できる形態**になってからバックエンドに引き渡す。

### 1.2 現代 ERP の誤謬：「一人の巨人」幻想

Oracle・SAP 等の従来型アプリは、**一人の大きな巨人**を作ろうとしている。

- **現実**: ビジネスは **10 個以上の臓器**で構成される
- **臓器同士**: **境界面（ホログラフィー）**で分離されている
- **問題**: 境界面の定義を欠いたモノリシック設計は、臓器の役割を混同し、技術負債を生む

### 1.3 屠畜牛の誤謬：軽い処理の組み合わせへ

**あらゆるアプリケーションは軽い処理の組み合わせに変わるはずである。**

現代のシステムのよくある間違いは、**屠畜処理されたての牛の切り身を持ってきて丸ごと口に放り込もうとしている**ことである。

| 段階 | 処理 | システム対応 |
|------|------|-------------|
| **口に入れる前** | 細菌感染チェック、調理、味付け、カット、盛り付け | フロントエンドでの分類・検証・フォーマット変換 |
| **食べた後** | 咀嚼、唾液、胃、膵液、腸で消化 | API 層・ミドルウェアでの正規化・変換 |
| **引き継ぎ** | 肝臓・腎臓へ | バックエンド（DB）へ。処理済みデータのみ |

**フロントエンドで分類が終わっていないものをバックエンドに流せば、体内で消化に時間がかかってしまうのは当然である。現代的な基幹システムはこの状態にある。**

→ 各段階を**軽い処理**に分解し、口に入る前に前処理を完結させる設計が HST の目指す姿である。

---

## 2. ホログラフィック原理：境界面の定義

### 2.1 事象の地平線（イベントホライズン）としての https://

質量が増した現代のソフトウェアは、**事象の地平線**のように `https://` という境界面が機能する。

| 物理的メタファー | ソフトウェアの現実 | GAAS における実装 |
|-----------------|-------------------|-------------------|
| **ブラックホールの内側** | サーバー・Docker 内部 | 観測不能（抽象化）。特異点として自動実行 |
| **事象の地平線（境界面）** | ユーザーが触れる唯一の現実 | TypeScript の型、SolidJS の Signal、Tailwind のクラス名 |
| **境界面の振動** | リアクティブな更新 | SolidJS (Signals) |
| **観測（アクセス）** | プロトコル | https:// (PWA) |

### 2.2 臓器＝Object、境界面＝Morphism

| 概念 | 数学的対応 | 説明 |
|------|-----------|------|
| **臓器（Organ）** | Object | 肝臓、胃、口… 各機能単位。10 個以上の独立したモジュール |
| **境界面（Boundary）** | Morphism | 臓器間のインターフェース。型・契約・プロトコルで定義 |
| **情報の流れ** | Arrow (射) | 口 → 胃 → 腸 → 肝臓。生データは境界面を越える前に変換される |

**ホログラフィーの定義**: 臓器同士は境界面で分離され、**境界面上の情報のみが交換される**。内部実装は観測不能（抽象化）である。

### 2.3 系内部と系外部の境界違反：毒の原則

| 領域 | 役割の例 | システム対応 |
|------|----------|-------------|
| **系外部** | 加熱、調理、カット | フロントエンド・API 層。入力の前処理 |
| **系内部** | 代謝・貯蔵・吸収 | データベース・バックエンド。処理済みデータのみ受け取る |

**原則**: 系内部の問題を系外部にやらせようとしたり、系外部がすべき問題（加熱・調理・カット）を系内部にやらせようとしても**不可能**であり、**毒を食べたのと同じ結果**となる。

| 違反パターン | 例 | 結果 |
|-------------|-----|------|
| 系内部の責務を系外部に | UI で複雑な集計・結合ロジック | パフォーマンス崩壊、一貫性破綻 |
| 系外部の責務を系内部に | DB 内で入力検証・フォーマット変換 | 肝臓に生肉を直投入。毒 |

境界を正しく守らない設計は、どちらの方向でも**システムの破壊**に至る。

---

## 3. システム開発の数学化

### 3.1 Object と Morphism への還元

上記の定義によると、**システム開発はほぼ Object と Morphism の数学的な問題に置き換えられる**。

| 従来の開発 | HST における開発 |
|-----------|------------------|
| コードを書く | Object（臓器）の定義と Morphism（境界面）の設計 |
| SQL を直接書く | 型（Drizzle）による境界面の記述。内部状態は一意に決まる |
| Docker で環境を固める | 境界面での実行（エッジ）。コンテナは不要 |
| モノリシックな巨人 | 10+ 臓器の組み合わせ。各臓器は Self-contained |

### 3.2 コードを打つという作業の位置づけ

**コードを打つという作業は、レガシー維持以外では起こり得ない化石となった。**

| 作業 | 役割 |
|------|------|
| **新規開発** | Object/Morphism の設計。型・契約・境界面の定義。AI が境界面上のコードを生成 |
| **レガシー維持** | 化石となった既存コードの修正。技術負債の償却 |
| **エンジニアの本質的役割** | 境界面への情報の記入。臓器間の Morphism の正しさの保証 |

### 3.3 次の時代：事業のブラックボックス球化

**あらゆるアプリケーションは軽い処理の組み合わせに変わるはずである。** 長い間聖域であったデータベースはサーバーレスになり、**ほぼ無料で稼げなくなる**。

次の時代で重要になるのは、次の知恵を持つことである。

| 活動 | 内容 |
|------|------|
| **境界面を定義** | 臓器間のインターフェースを型・契約で明示 |
| **Object をカテゴライズ・パッケージ化** | 機能単位を独立したモジュールとして整理 |
| **Morphism として定義** | 異なる Object 間の情報のやり取りを射として記述 |
| **プロセッシングの順序を最適化** | 軽い処理の組み合わせの流れを設計 |

**目的**: より大きな Object としての**事業**を、**資本の Input** と **純利益の Output** という単純なブラックボックス球に丸め込むことである。

```
資本 (Input) → [ Object₁ ⟷ Object₂ ⟷ … ⟷ Objectₙ ] → 純利益 (Output)
                    ↑ Morphism で接続、順序を最適化
```

内部の Object と Morphism を正しく設計すれば、事業全体は **Input/Output のみが観測可能な球** として表現される。これが HST の目指す事業モデルの抽象化である。

### 3.4 ブラックボックスの許容と推論による予測可能性

次の時代で重要なのは、**系内部を研究するのではなく**、**ブラックボックスを許容し**、**推論によって結果の予測可能性を実現する**知恵を持つことである。

| 従来のアプローチ | HST のアプローチ |
|-----------------|-----------------|
| 内部を開いて理解する | ブラックボックスを許容する |
| 実装の詳細に依存する | 境界面（Input/Output）のみに依存する |
| デバッグで原因を追う | 推論で結果を予測する |

系内部は観測不能（抽象化）であり、**境界面上の型・契約・プロトコル**から推論することで、結果の予測可能性を確保する。内部を開かずに、外部から制御可能にする。

---

## 4. GAAS 標準スタックとの対応

| 領域 | HST における位置づけ |
|------|---------------------|
| **SolidJS (Signals)** | 境界面の振動。部分変更が全体に波及しない |
| **Tailwind CSS v4** | 表面の模様。HTML 内で完結する境界面の記述 |
| **Drizzle ORM** | 型による境界面。SQL を直接書かず、型で統治 |
| **SQLite (LibSQL)** | 肝臓（DB）。単一ファイルで完結。サーバーレス/エッジで爆速 |
| **Bun** | 特異点。背後で自動実行。Docker 不要 |
| **https:// (PWA)** | 事象の地平線。全デバイスに URL ひとつで配信 |

---

## 5. 結論

1. **臓器メタファー**: ビジネスは 10+ 臓器で構成され、臓器同士は境界面で分離される
2. **屠畜牛の誤謬**: 丸ごと口に放り込むのではなく、口に入れる前に前処理を完結させる。アプリは軽い処理の組み合わせへ
3. **DB のコモディティ化**: 長く聖域であったデータベースはサーバーレス化し、ほぼ無料で稼げなくなる
4. **ホログラフィック原理**: 境界面上の情報のみが交換される。内部は観測不能
5. **毒の原則**: 系内部と系外部の責務を逆転させると不可能であり、毒を食べたのと同じ結果となる
6. **数学化**: 開発は Object と Morphism の設計問題に還元される
7. **事業のブラックボックス球**: 境界面・Object・Morphism を設計し、プロセッシング順序を最適化することで、事業を資本 Input → 純利益 Output の単純な球に丸め込む
8. **ブラックボックスの許容**: 系内部を研究するのではなく、ブラックボックスを許容し、推論によって結果の予測可能性を実現する
9. **コードの役割**: 新規開発では境界面の記述が主。レガシー維持以外で「コードを打つ」は化石

---

## 6. 更新履歴

| 日付 | 変更内容 |
|-----|----------|
| 2026-02-27 | 初版作成（HST 基本概念、臓器メタファー、Object/Morphism 定義） |
| 2026-02-27 | 2.3 系内部と系外部の境界違反（毒の原則）を追加 |
| 2026-02-27 | 1.3 屠畜牛の誤謬、軽い処理の組み合わせ、消化パイプラインを追加 |
| 2026-02-27 | 3.3 次の時代：DB コモディティ化、事業のブラックボックス球化を追加 |
| 2026-02-27 | 3.4 ブラックボックスの許容と推論による予測可能性を追加 |
